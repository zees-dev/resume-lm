{{- if and .Values.db.enabled (not .Values.db.external.enabled) }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "resumelm.fullname" . }}-db-init
  labels:
    {{- include "resumelm.labels" . | nindent 4 }}
    app.kubernetes.io/component: database
data:
  00-set-passwords.sql: |
    -- Supabase Database Initialization
    -- Creates roles, schemas, and types needed for Supabase services

    -- Enable required extensions
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    CREATE EXTENSION IF NOT EXISTS "pgcrypto";

    -- Create roles with passwords
    DO $$
    BEGIN
        -- postgres role (required by GoTrue migrations)
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'postgres') THEN
            CREATE ROLE postgres SUPERUSER LOGIN PASSWORD '{{ .Values.secrets.postgresPassword }}';
        END IF;

        -- Authenticator (PostgREST)
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'authenticator') THEN
            CREATE ROLE authenticator NOINHERIT LOGIN PASSWORD '{{ .Values.secrets.postgresPassword }}';
        END IF;

        -- Anonymous role
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'anon') THEN
            CREATE ROLE anon NOLOGIN NOINHERIT;
        END IF;

        -- Authenticated role
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'authenticated') THEN
            CREATE ROLE authenticated NOLOGIN NOINHERIT;
        END IF;

        -- Service role (bypasses RLS)
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'service_role') THEN
            CREATE ROLE service_role NOLOGIN NOINHERIT BYPASSRLS;
        END IF;

        -- Supabase admin
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'supabase_admin') THEN
            CREATE ROLE supabase_admin SUPERUSER LOGIN PASSWORD '{{ .Values.secrets.postgresPassword }}';
        END IF;

        -- Auth admin (superuser for migrations)
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'supabase_auth_admin') THEN
            CREATE ROLE supabase_auth_admin SUPERUSER NOINHERIT CREATEROLE LOGIN PASSWORD '{{ .Values.secrets.postgresPassword }}';
        END IF;

        -- Storage admin (superuser for migrations)
        IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'supabase_storage_admin') THEN
            CREATE ROLE supabase_storage_admin SUPERUSER NOINHERIT CREATEROLE LOGIN PASSWORD '{{ .Values.secrets.postgresPassword }}';
        END IF;
    END $$;

    -- Grant role memberships
    GRANT anon, authenticated, service_role TO authenticator;

    -- Create schemas
    CREATE SCHEMA IF NOT EXISTS auth AUTHORIZATION supabase_auth_admin;
    CREATE SCHEMA IF NOT EXISTS storage AUTHORIZATION supabase_storage_admin;
    CREATE SCHEMA IF NOT EXISTS _realtime AUTHORIZATION supabase_admin;
    CREATE SCHEMA IF NOT EXISTS realtime AUTHORIZATION supabase_admin;
    CREATE SCHEMA IF NOT EXISTS graphql_public;
    CREATE SCHEMA IF NOT EXISTS _analytics AUTHORIZATION supabase_admin;

    -- Set search paths for admin roles
    ALTER ROLE supabase_auth_admin SET search_path TO auth, public;
    ALTER ROLE supabase_storage_admin SET search_path TO storage, public;

    -- Schema permissions
    GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;
    GRANT USAGE ON SCHEMA auth TO anon, authenticated, service_role;
    GRANT USAGE ON SCHEMA graphql_public TO anon, authenticated, service_role;

    -- Default privileges for public schema
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO anon, authenticated, service_role;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon, authenticated, service_role;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO anon, authenticated, service_role;

    -- Auth helper functions (stubs for RLS policies)
    CREATE OR REPLACE FUNCTION auth.uid()
    RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
      SELECT
        COALESCE(
          current_setting('request.jwt.claim.sub', true),
          (current_setting('request.jwt.claims', true)::jsonb ->> 'sub')
        )::uuid
    $$;

    CREATE OR REPLACE FUNCTION auth.role()
    RETURNS text
    LANGUAGE sql STABLE
    AS $$
      SELECT
        COALESCE(
          current_setting('request.jwt.claim.role', true),
          (current_setting('request.jwt.claims', true)::jsonb ->> 'role')
        )::text
    $$;

    -- Auth types (required by GoTrue migrations)
    SET ROLE supabase_auth_admin;

    DO $$ BEGIN CREATE TYPE auth.aal_level AS ENUM ('aal1', 'aal2', 'aal3'); EXCEPTION WHEN duplicate_object THEN null; END $$;
    DO $$ BEGIN CREATE TYPE auth.code_challenge_method AS ENUM ('s256', 'plain'); EXCEPTION WHEN duplicate_object THEN null; END $$;
    DO $$ BEGIN CREATE TYPE auth.factor_status AS ENUM ('unverified', 'verified'); EXCEPTION WHEN duplicate_object THEN null; END $$;
    DO $$ BEGIN CREATE TYPE auth.factor_type AS ENUM ('totp', 'webauthn'); EXCEPTION WHEN duplicate_object THEN null; END $$;
    DO $$ BEGIN CREATE TYPE auth.one_time_token_type AS ENUM ('confirmation_token', 'reauthentication_token', 'recovery_token', 'email_change_token_new', 'email_change_token_current', 'phone_change_token'); EXCEPTION WHEN duplicate_object THEN null; END $$;

    RESET ROLE;

  01-app-schema.sql: |
    -- ResumeLM Application Schema

    -- Create updated_at trigger function
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Subscriptions table
    CREATE TABLE IF NOT EXISTS public.subscriptions (
      user_id uuid NOT NULL,
      stripe_customer_id text NULL,
      stripe_subscription_id text NULL,
      subscription_plan text NULL DEFAULT 'free'::text,
      subscription_status text NULL,
      current_period_end timestamp with time zone NULL,
      trial_end timestamp with time zone NULL,
      created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
      updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
      CONSTRAINT subscriptions_pkey PRIMARY KEY (user_id),
      CONSTRAINT subscriptions_user_id_key UNIQUE (user_id),
      CONSTRAINT subscriptions_stripe_subscription_id_key UNIQUE (stripe_subscription_id),
      CONSTRAINT subscriptions_stripe_customer_id_key UNIQUE (stripe_customer_id),
      CONSTRAINT subscriptions_subscription_plan_check CHECK (
        subscription_plan = ANY (ARRAY['free'::text, 'pro'::text])
      ),
      CONSTRAINT subscriptions_subscription_status_check CHECK (
        (subscription_status IS NULL) OR (subscription_status = ANY (ARRAY['active'::text, 'canceled'::text]))
      )
    ) TABLESPACE pg_default;

    DROP TRIGGER IF EXISTS update_subscriptions_updated_at ON public.subscriptions;
    CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON subscriptions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

    -- Jobs table
    CREATE TABLE IF NOT EXISTS public.jobs (
      id uuid NOT NULL DEFAULT uuid_generate_v4(),
      user_id uuid NOT NULL,
      company_name text NULL,
      position_title text NOT NULL,
      job_url text NULL,
      description text NULL,
      location text NULL,
      salary_range text NULL,
      keywords jsonb NULL DEFAULT '[]'::jsonb,
      work_location text NULL DEFAULT 'in_person'::text,
      employment_type text NULL DEFAULT 'full_time'::text,
      is_active boolean NULL DEFAULT true,
      created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
      updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
      CONSTRAINT jobs_pkey PRIMARY KEY (id)
    ) TABLESPACE pg_default;

    DROP TRIGGER IF EXISTS update_jobs_updated_at ON public.jobs;
    CREATE TRIGGER update_jobs_updated_at BEFORE UPDATE ON jobs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

    -- Resumes table
    CREATE TABLE IF NOT EXISTS public.resumes (
      id uuid NOT NULL DEFAULT uuid_generate_v4(),
      user_id uuid NOT NULL,
      job_id uuid NULL,
      is_base_resume boolean NULL DEFAULT false,
      name text NOT NULL,
      first_name text NULL,
      last_name text NULL,
      email text NULL,
      phone_number text NULL,
      location text NULL,
      website text NULL,
      linkedin_url text NULL,
      github_url text NULL,
      professional_summary text NULL,
      work_experience jsonb NULL DEFAULT '[]'::jsonb,
      education jsonb NULL DEFAULT '[]'::jsonb,
      skills jsonb NULL DEFAULT '[]'::jsonb,
      projects jsonb NULL DEFAULT '[]'::jsonb,
      certifications jsonb NULL DEFAULT '[]'::jsonb,
      section_order jsonb NULL DEFAULT '["professional_summary", "work_experience", "skills", "projects", "education", "certifications"]'::jsonb,
      section_configs jsonb NULL DEFAULT '{"skills": {"style": "grouped", "visible": true}, "projects": {"visible": true, "max_items": 3}, "education": {"visible": true, "max_items": null}, "certifications": {"visible": true}, "work_experience": {"visible": true, "max_items": null}}'::jsonb,
      created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
      updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
      resume_title text NULL,
      target_role text NULL,
      document_settings jsonb NULL DEFAULT '{"header_name_size": 24, "skills_margin_top": 2, "document_font_size": 10, "projects_margin_top": 2, "skills_item_spacing": 2, "document_line_height": 1.5, "education_margin_top": 2, "skills_margin_bottom": 2, "experience_margin_top": 2, "projects_item_spacing": 4, "education_item_spacing": 4, "projects_margin_bottom": 2, "education_margin_bottom": 2, "experience_item_spacing": 4, "document_margin_vertical": 36, "experience_margin_bottom": 2, "skills_margin_horizontal": 0, "document_margin_horizontal": 36, "header_name_bottom_spacing": 24, "projects_margin_horizontal": 0, "education_margin_horizontal": 0, "experience_margin_horizontal": 0}'::jsonb,
      has_cover_letter boolean NOT NULL DEFAULT false,
      cover_letter jsonb NULL,
      CONSTRAINT resumes_pkey PRIMARY KEY (id),
      CONSTRAINT resumes_job_id_fkey FOREIGN KEY (job_id) REFERENCES jobs(id) ON UPDATE CASCADE ON DELETE CASCADE
    ) TABLESPACE pg_default;

    DROP TRIGGER IF EXISTS update_resumes_updated_at ON public.resumes;
    CREATE TRIGGER update_resumes_updated_at BEFORE UPDATE ON resumes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

    -- Profiles table
    CREATE TABLE IF NOT EXISTS public.profiles (
      user_id uuid NOT NULL,
      first_name text NULL,
      last_name text NULL,
      email text NULL,
      created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
      updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
      phone_number text NULL,
      location text NULL,
      website text NULL,
      linkedin_url text NULL,
      github_url text NULL,
      work_experience jsonb NULL DEFAULT '[]'::jsonb,
      education jsonb NULL DEFAULT '[]'::jsonb,
      skills jsonb NULL DEFAULT '[]'::jsonb,
      projects jsonb NULL DEFAULT '[]'::jsonb,
      certifications jsonb NULL DEFAULT '[]'::jsonb,
      CONSTRAINT profiles_pkey PRIMARY KEY (user_id),
      CONSTRAINT profiles_user_id_key UNIQUE (user_id)
    ) TABLESPACE pg_default;

    DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles;
    CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

    -- Setup Row Level Security (RLS) Policies
    ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS subscriptions_policy ON public.subscriptions;
    CREATE POLICY subscriptions_policy ON public.subscriptions
      USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

    ALTER TABLE public.resumes ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS resumes_policy ON public.resumes;
    CREATE POLICY resumes_policy ON public.resumes
      USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

    ALTER TABLE public.jobs ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS jobs_policy ON public.jobs;
    CREATE POLICY jobs_policy ON public.jobs
      USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS profiles_policy ON public.profiles;
    CREATE POLICY profiles_policy ON public.profiles
      USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

    -- Grant permissions on tables
    GRANT ALL ON public.subscriptions TO authenticated;
    GRANT ALL ON public.resumes TO authenticated;
    GRANT ALL ON public.jobs TO authenticated;
    GRANT ALL ON public.profiles TO authenticated;
    GRANT SELECT ON public.subscriptions TO anon;
    GRANT SELECT ON public.resumes TO anon;
    GRANT SELECT ON public.jobs TO anon;
    GRANT SELECT ON public.profiles TO anon;
{{- end }}
